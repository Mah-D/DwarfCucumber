'use strict';

var fs = require('fs'),
	path = require('path'),
	util = require('util'),
	nodeunit = require('../../node_modules/nodeunit/lib/nodeunit'),
	utils = require('../../node_modules/nodeunit/lib/utils'),
	track = require('../../node_modules/nodeunit/lib/track'),
	assert = require('../../node_modules/nodeunit/lib/assert'),
	AssertionError = assert.AssertionError;

exports.info = 'Pragma Dudes tests reporter';

var defaultOptionsPath = path.join(__dirname,
		'../../node_modules/nodeunit/bin/nodeunit.json'),
	options;

/**
 * Run all tests within each module, reporting the results to the command-line.
 * @param {Array} files Files to run.
 * @param {object} currentOptions Current options set.
 * @param {function} callback Result callback.
 */
exports.run = function (files, currentOptions, callback) {

	initOptions(currentOptions);

	var	tracker = createTracker(),
		opts = {
			testspec: options.testspec,
			testFullSpec: options.testFullSpec,

			moduleStart: function (name) {
				console.log('\n' + printBold(name));
			},
			done: done.bind(this, callback),

			testStart: function (name) {
				tracker.put(name);
			},
			testDone: testDone.bind(this, tracker)
		};

	if (files && files.length) {
		var paths = files.map(function (filePath) {
			return path.join(process.cwd(), filePath);
		});
		nodeunit.runFiles(paths, opts);
	} else {
		nodeunit.runModules(files, opts);
	}
};

function createTracker() {
	return track.createTracker(function (tracker) {
		if (!tracker.unfinished()) {
			return;
		}

		console.log('');
		console.log(printError(printBold(
			'FAILURES: Undone tests (or their setups/teardowns): '
		)));

		tracker
			.names()
			.forEach(function (name) {
				console.log('- ' + name);
			});

		console.log('');
		console.log('To fix this, make sure all tests call test.done()');
		process.reallyExit(tracker.unfinished());
	});
}

function initOptions(currentOptions) {
	if (!currentOptions) {
		var content = fs.readFileSync(defaultOptionsPath, 'utf8');
		options = JSON.parse(content);
		return;
	}

	options = currentOptions;
}

function done(callback, assertions) {
	if (assertions.failures()) {
		var failMessage = util.format('\n%s%s/%d assertions failed (%dms)',
			printBold(printError('FAILURES: ')),
			assertions.failures(),
			assertions.length,
			assertions.duration);

		console.log(failMessage);

	} else {
		var okMessage = util.format('\n%s%d assertions (%dms)',
			printBold(printOk('OK: ')),
			assertions.length,
			assertions.duration);

		console.log(okMessage);
	}

	if (callback) {
		var error = assertions.failures() ?
			new Error('We have got test failures.') :
			undefined;

		callback(error);
	}

	if (!assertions.failures()) {
		process.exit(0);
	}
}

function testDone(tracker, name, assertions) {
	tracker.remove(name);

	if (!assertions.failures()) {
		console.log('✔ ' + name);
	} else {
		console.log(printError('✖ ' + name) + '\n');
		assertions.forEach(assertionHandler);
	}
}

function assertionHandler(assertion) {
	if (!assertion.failed()) {
		return;
	}

	var advancedAssertion = utils.betterErrors(assertion);

	if (advancedAssertion.error instanceof AssertionError &&
		advancedAssertion.message) {

		var message = util.format('Assertion Message: %s',
			printAssertionMessage(advancedAssertion.message));

		console.log(message);
	}

	console.log(advancedAssertion.error.stack + '\n');
}

function printError(str) {
	// jshint camelcase: false
	return options.error_prefix +
		str +
		options.error_suffix;
}

function printOk(str) {
	// jshint camelcase: false
	return options.ok_prefix +
		str +
		options.ok_suffix;
}

function printBold(str) {
	// jshint camelcase: false
	return options.bold_prefix +
		str +
		options.bold_suffix;
}

function printAssertionMessage(str) {
	// jshint camelcase: false
	return options.assertion_prefix +
		str +
		options.assertion_suffix;
}